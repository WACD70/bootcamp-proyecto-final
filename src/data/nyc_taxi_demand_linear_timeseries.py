# -*- coding: utf-8 -*-
"""NYC_Taxi_Demand_Linear_TimeSeries.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FL67nbK18zLoXcy18FjLbnvUIzt3kk18

# NYC Taxi Demand Linear Regression & Time Series
Notebook simple para cumplir requisitos del proyecto:
- Regresión lineal
- Modelado de series de tiempo (ARIMA o Prophet opcional)
"""

#pip install -r requirements.txt

"""## 1. Carga de datos"""

import pandas as pd
from google.colab import files
import kagglehub
import os
from clean_dataset import limpiar_dataset
from visualization.visualize import sarima_train_res_stat
from features.build_features import entrenar_sarima_feature
from visualization.visualize import graficar_forecast_veinticuatro_horas
# Download latest version
path = kagglehub.dataset_download("elemento/nyc-yellow-taxi-trip-data")

# Find the CSV file within the downloaded directory
csv_files = [f for f in os.listdir(path) if f.endswith('.csv')]
if not csv_files:
    raise FileNotFoundError("No CSV file found in the downloaded dataset directory.")

# Assuming there's only one CSV file or we want the first one
csv_file_path = os.path.join(path, csv_files[0])

df = pd.read_csv(csv_file_path)
df.head()

"""## 2. Preprocesamiento mínimo"""

df = limpiar_dataset(df)

"""## 3. Regresión lineal"""

from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
demand = {}
demand['month'] = demand['pickup_hour'].dt.month
demand['is_weekend'] = demand['pickup_hour'].dt.dayofweek.isin([5,6]).astype(int)
demand['is_rush_hour'] = demand['hour'].isin([7,8,9,16,17,18,19]).astype(int)
demand['rolling_mean_3h'] = demand['trip_count'].rolling(window=3, min_periods=1).mean()

X = demand[['hour', 'dayofweek', 'month', 'is_weekend', 'is_rush_hour', 'rolling_mean_3h']]
y = demand['trip_count']

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

lr = LinearRegression()
lr.fit(X_train, y_train)

print("R²:", lr.score(X_test, y_test))

"""## 4. Series de tiempo – ejemplo ARIMA simple"""

import statsmodels.api as sm

# 1. Construimos la serie temporal indexada por la hora
ts = demand.set_index('pickup_hour')['trip_count']

# 2. Es MUY recomendable convertir el índice a datetime (por si acaso)
ts.index = pd.to_datetime(ts.index)

# 3. Ajustamos el modelo ARIMA (1,1,1) como en tu código original
model = sm.tsa.ARIMA(ts, order=(1,1,1))
res = model.fit()

# 4. Mostrar resumen del modelo
res.summary()

"""## 5. Predicción de series de tiempo"""

pred = res.forecast(24)
pred.plot()

from sklearn.metrics import mean_absolute_error, mean_squared_error
import numpy as np

# -----------------------------
# 1. Crear split train/test temporal
# -----------------------------
# Usaremos el último 20% como test
split_index = int(len(ts) * 0.8)

train_ts = ts.iloc[:split_index]
test_ts  = ts.iloc[split_index:]

# -----------------------------
# 2. Entrenar ARIMA con train
# -----------------------------
model = sm.tsa.ARIMA(train_ts, order=(1,1,1))
res = model.fit()

# -----------------------------
# 3. Predecir el periodo del test
# -----------------------------
pred = res.forecast(steps=len(test_ts))

# -----------------------------
# 4. Métricas de evaluación
# -----------------------------
mae = mean_absolute_error(test_ts, pred)
rmse = np.sqrt(mean_squared_error(test_ts, pred))

print("MAE:", mae)
print("RMSE:", rmse)

# Mostrar primeras filas
comparison = pd.DataFrame({
    "real": test_ts,
    "predicción": pred
})
comparison.head()

import matplotlib.pyplot as plt

plt.figure(figsize=(14,5))
plt.plot(train_ts.index, train_ts, label="Train")
plt.plot(test_ts.index, test_ts, label="Real (Test)", color="green")
plt.plot(test_ts.index, pred, label="Predicción ARIMA", color="red")

plt.title("Comparación: Predicción ARIMA vs Valores Reales")
plt.xlabel("Fecha")
plt.ylabel("Demanda por hora")
plt.legend()
plt.show()

# Entrenamos ARIMA con TODA la serie
model_full = sm.tsa.ARIMA(ts, order=(1,1,1))
res_full = model_full.fit()

# Forecasting
forecast_24 = res_full.forecast(steps=24)
forecast_48 = res_full.forecast(steps=48)

# Graficar forecast de 24 horas
graficar_forecast_veinticuatro_horas(ts,res_full,train_ts,test_ts,pred)

import statsmodels.api as sm
# ============================
# 1. Modelo SARIMA
# ============================

sarima_model = sm.tsa.statespace.SARIMAX(
    ts,
    order=(1, 1, 1),              # ARIMA(p,d,q)
    seasonal_order=(1, 1, 1, 24), # SARIMA(P,D,Q,s)
    enforce_stationarity=False,
    enforce_invertibility=False
)

sarima_res = sarima_model.fit()

print(sarima_res.summary())

sarima_train_res = entrenar_sarima_feature(train_ts)

# Predecimos el tamaño exacto del test
sarima_train_res_stat(test_ts,train_ts,sarima_train_res)
